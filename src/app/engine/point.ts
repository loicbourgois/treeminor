import { Color } from './color';
import { Vector } from './vector';
import { Utils } from './utils';

export class Point {

  private position: Vector;
  private speed: Vector;
  private radius: number;
  private color: Color;
  private mass: number;
  private acceleration: Vector;
  private DISTANCE_TOLERANCE = 0.01;
  private forces: Vector;
  private oldPosition: Vector;

  constructor(point: any) {
    this.loadConfiguration(point);
  }

  loadConfiguration(configuration: any) {
    const point = Utils.getCheckedConfiguration(configuration);
    this.position = new Vector(point.position);
    this.speed = new Vector(point.speed);
    this.radius = (point.radius !== undefined) ? point.radius : 1.0;
    this.color = new Color(point.color);
    this.mass = (point.mass !== undefined) ? point.mass : 1.0;
    this.acceleration = new Vector(point.acceleration);
    this.forces = new Vector(point.forces);
    this.oldPosition = new Vector(point.oldPosition);
    if (!this.speed.getX() && !this.speed.getY()) {
      this.speed.set(0.0, 0.0);
    }
    const deltaTime = 0.05 / 1000.0;
    if (this.oldPosition.getX() === undefined || this.oldPosition.getY() === undefined) {
      this.oldPosition.set(
        this.position.getX() - this.speed.getX() * deltaTime,
        this.position.getY() - this.speed.getY() * deltaTime);
    }
  }

  resetAcceleration() {
    this.acceleration.set(0.0, 0.0);
  }

  resetForces() {
    this.forces.set(0.0, 0.0);
  }

  updateAcceleration() {
    const xAcceleration = this.forces.getX() / this.mass;
    const yAcceleration = this.forces.getY() / this.mass;
    this.acceleration.set(xAcceleration, yAcceleration);
  }

  //
  //
  //
  updatePositionVerlet(deltaTime) {

    const currentX = this.position.getX();
    const currentY = this.position.getY();

    const newX = 2 * currentX - this.oldPosition.getX() + this.acceleration.getX() * deltaTime * deltaTime ;
    const newY = 2 * currentY - this.oldPosition.getY() + this.acceleration.getY() * deltaTime * deltaTime ;

    this.oldPosition.set(currentX, currentY);
    this.position.set(newX, newY);
  }

  //
  // Put back a point inside its world if it is outside
  //
  recenter(worldWidth, worldHeight) {
    const xMax = worldWidth / 2;
    const xMin = -xMax;
    const yMax = worldHeight / 2;
    const yMin = -yMax;
    let x = this.position.getX() + xMax - xMin - xMin;
    while (x > (xMax - xMin)) {
      x -= (xMax - xMin);
    }
    x += xMin;
    let y = this.position.getY() + yMax - yMin - yMin;
    while (y > (yMax - yMin)) {
      y -= (yMax - yMin);
    }
    y += yMin;
    this.position.set(x, y);
  }

  //
  // Add all the gravitational forces to a point
  // generated by all the other points.
  //
  // These forces are added to the point's forces.
  //
  addGravityForces(points, gravity, worldWidth, worldHeight) {
    points.forEach(point => {
      if (point !== this) {
        const fourClosestPosition = Vector.getFourClosestClonesAsArrays(this.position, point.position, worldWidth, worldHeight);
        if (fourClosestPosition) {
          fourClosestPosition.forEach(position => {
            const x = position[0];
            const y = position[1];
            const distance = Vector.getDistanceToCoordinates(this.position, x, y);
            const force = distance > this.DISTANCE_TOLERANCE ? - gravity * this.mass * point.mass / (distance * distance) : 0.0;
            const xDelta = this.position.getX() - x;
            const yDelta = this.position.getY() - y;
            const xForce = xDelta * force;
            const yForce = yDelta * force;
            this.forces.add(xForce, yForce);
          });
        } else {
          // NTD
        }
      } else {
        // NTD
      }
    });
  }

  updateSpeed(delta) {
    const xSpeed = this.speed.getX() + this.acceleration.getX() * delta;
    const ySpeed = this.speed.getY() + this.acceleration.getY() * delta;
    this.speed.set(xSpeed, ySpeed);
  }

  move(deltaTime: number) {
    this.position.set(
        this.position.getX() + this.speed.getX() * deltaTime,
        this.position.getY() + this.speed.getY() * deltaTime);
  }

  getPosition() {
    return this.position;
  }
}
